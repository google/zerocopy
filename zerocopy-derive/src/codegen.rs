//! Code generation is implemented as a zerocopy-derive unit test, because that
//! allows us to share code with zerocopy-derive.

use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::{parse_quote, Generics, Ident, Type};

use crate::{FieldBounds, ImplBlockBuilder, Trait, Tuple};

fn tuples() -> TokenStream {
    let fields: Vec<Type> = ('A'..='Z')
        .map(|ident: char| {
            let ident = Ident::new(&ident.to_string(), Span::call_site());
            parse_quote!(#ident)
        })
        .collect();

    let impls = (1..=fields.len()).map(|arity| {
        let fields = &fields[0..arity];
        let generics: Generics = parse_quote!(<#(#fields,)*>);
        let tuple = Tuple::new(fields);

        ImplBlockBuilder::new(
            None,
            &generics,
            &tuple,
            Trait::Immutable,
            FieldBounds::ALL_SELF,
            &parse_quote!(crate),
        )
        .build()
    });
    quote! {
        #(#impls)*
    }
}

const HEADER: &dyn ToString = &"\
// Copyright 2025 The Fuchsia Authors
// 
// Licensed under a BSD-style license <LICENSE-BSD>, Apache License, Version 2.0
// <LICENSE-APACHE or https://www.apache.org/licenses/LICENSE-2.0>, or the MIT
// license <LICENSE-MIT or https://opensource.org/licenses/MIT>, at your option.
// This file may not be copied, modified, or distributed except according to
// those terms.

// WARNING: DO NOT EDIT THIS FILE. It is generated automatically. Edits should be
// made in `tools/codegen`.

// Do not lint generated code.
#![allow(warnings)]
#![allow(
    clippy::all,
    clippy::correctness,
    clippy::suspicious,
    clippy::style,
    clippy::complexity,
    clippy::perf,
    clippy::pedantic,
    clippy::restriction,
    clippy::nursery,
)]
";

#[test]
fn codegen() {
    let path = {
        use std::path::PathBuf;
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        assert!(path.pop());
        path.push("src");
        path.push("generated.rs");
        path
    };

    let generated = [HEADER, &tuples()].map(ToString::to_string).join("\n");

    std::fs::write(path, generated.as_bytes()).unwrap();
}
