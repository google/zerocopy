error[E0277]: the trait bound `NotZerocopy: TryFromBytes` is not satisfied
 --> tests/ui-stable/try_transmute_ref-dst-not-immutable-tryfrombytes.rs:17:59
  |
 17 |     let dst_not_try_from_bytes: Result<&NotZerocopy, _> = try_transmute_ref!(&AU16(0));
    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound
    |
help: the trait `TryFromBytes` is not implemented for `NotZerocopy`
   --> tests/ui-stable/../include.rs
    |
 15 |     pub struct NotZerocopy<T = ()>(pub T);
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: Consider adding `#[derive(TryFromBytes)]` to `NotZerocopy`
    = help: the following other types implement trait `TryFromBytes`:
              ()
              (A, B)
              (A, B, C)
              (A, B, C, D)
              (A, B, C, D, E)
              (A, B, C, D, E, F)
              (A, B, C, D, E, F, G)
              (A, B, C, D, E, F, G, H)
              (A, B, C, D, E, F, G, H, I)
              (A, B, C, D, E, F, G, H, I, J)
              (A, B, C, D, E, F, G, H, I, J, K)
              (A, B, C, D, E, F, G, H, I, J, K, L)
              (A, B, C, D, E, F, G, H, I, J, K, L, M)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z)
              (A,)
              *const T
              *mut T
              AU16
              AtomicBool
              AtomicI16
              AtomicI32
              AtomicI64
              AtomicI8
              AtomicIsize
              AtomicPtr<T>
              AtomicU16
              AtomicU32
              AtomicU64
              AtomicU8
              AtomicUsize
              Cell<T>
              F32<O>
              F64<O>
              I128<O>
              I16<O>
              I32<O>
              I64<O>
              Isize<O>
              ManuallyDrop<T>
              NonZero<i128>
              NonZero<i16>
              NonZero<i32>
              NonZero<i64>
              NonZero<i8>
              NonZero<isize>
              NonZero<u128>
              NonZero<u16>
              NonZero<u32>
              NonZero<u64>
              NonZero<u8>
              NonZero<usize>
              Option<&T>
              Option<&mut T>
              Option<Box<T>>
              Option<NonNull<T>>
              Option<NonZero<i128>>
              Option<NonZero<i16>>
              Option<NonZero<i32>>
              Option<NonZero<i64>>
              Option<NonZero<i8>>
              Option<NonZero<isize>>
              Option<NonZero<u128>>
              Option<NonZero<u16>>
              Option<NonZero<u32>>
              Option<NonZero<u64>>
              Option<NonZero<u8>>
              Option<NonZero<usize>>
              Option<extern "C" fn() -> M>
              Option<extern "C" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(G, H, I, J, K, L) -> M>
              Option<extern "C" fn(H, I, J, K, L) -> M>
              Option<extern "C" fn(I, J, K, L) -> M>
              Option<extern "C" fn(J, K, L) -> M>
              Option<extern "C" fn(K, L) -> M>
              Option<extern "C" fn(L) -> M>
              Option<fn() -> M>
              Option<fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(E, F, G, H, I, J, K, L) -> M>
              Option<fn(F, G, H, I, J, K, L) -> M>
              Option<fn(G, H, I, J, K, L) -> M>
              Option<fn(H, I, J, K, L) -> M>
              Option<fn(I, J, K, L) -> M>
              Option<fn(J, K, L) -> M>
              Option<fn(K, L) -> M>
              Option<fn(L) -> M>
              Option<unsafe extern "C" fn() -> M>
              Option<unsafe extern "C" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(I, J, K, L) -> M>
              Option<unsafe extern "C" fn(J, K, L) -> M>
              Option<unsafe extern "C" fn(K, L) -> M>
              Option<unsafe extern "C" fn(L) -> M>
              Option<unsafe fn() -> M>
              Option<unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(G, H, I, J, K, L) -> M>
              Option<unsafe fn(H, I, J, K, L) -> M>
              Option<unsafe fn(I, J, K, L) -> M>
              Option<unsafe fn(J, K, L) -> M>
              Option<unsafe fn(K, L) -> M>
              Option<unsafe fn(L) -> M>
              PhantomData<T>
              ReadOnly<T>
              U128<O>
              U16<O>
              U32<O>
              U64<O>
              Unalign<T>
              UnsafeCell<T>
              Usize<O>
              Wrapping<T>
              [T; N]
              [T]
              __m128
              __m128d
              __m128i
              __m256
              __m256d
              __m256i
              __m512
              __m512bh
              __m512d
              __m512i
              bool
              char
              f32
              f64
              i128
              i16
              i32
              i64
              i8
              isize
              std::mem::MaybeUninit<T>
              str
              u128
              u16
              u32
              u64
              u8
              usize
note: required by a bound in `Wrap::<&'a Src, &'a Dst>::try_transmute_ref`
   --> src/util/macro_util.rs
    |
    |     pub fn try_transmute_ref(self) -> Result<&'a Dst, ValidityError<&'a Src, Dst>>
    |            ----------------- required by a bound in this associated function
...
    |         Dst: TryFromBytes + Immutable,
    |              ^^^^^^^^^^^^ required by this bound in `Wrap::<&Src, &Dst>::try_transmute_ref`
    = note: this error originates in the macro `try_transmute_ref` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `NotZerocopy: Immutable` is not satisfied
 --> tests/ui-stable/try_transmute_ref-dst-not-immutable-tryfrombytes.rs:17:59
  |
 17 |     let dst_not_try_from_bytes: Result<&NotZerocopy, _> = try_transmute_ref!(&AU16(0));
    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound
    |
help: the trait `Immutable` is not implemented for `NotZerocopy`
   --> tests/ui-stable/../include.rs
    |
 15 |     pub struct NotZerocopy<T = ()>(pub T);
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: Consider adding `#[derive(Immutable)]` to `NotZerocopy`
    = help: the following other types implement trait `Immutable`:
              &T
              &mut T
              ()
              (A, B)
              (A, B, C)
              (A, B, C, D)
              (A, B, C, D, E)
              (A, B, C, D, E, F)
              (A, B, C, D, E, F, G)
              (A, B, C, D, E, F, G, H)
              (A, B, C, D, E, F, G, H, I)
              (A, B, C, D, E, F, G, H, I, J)
              (A, B, C, D, E, F, G, H, I, J, K)
              (A, B, C, D, E, F, G, H, I, J, K, L)
              (A, B, C, D, E, F, G, H, I, J, K, L, M)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z)
              (A,)
              *const T
              *mut T
              AU16
              Box<T>
              F32<O>
              F64<O>
              I128<O>
              I16<O>
              I32<O>
              I64<O>
              Isize<O>
              ManuallyDrop<T>
              NonNull<T>
              NonZero<i128>
              NonZero<i16>
              NonZero<i32>
              NonZero<i64>
              NonZero<i8>
              NonZero<isize>
              NonZero<u128>
              NonZero<u16>
              NonZero<u32>
              NonZero<u64>
              NonZero<u8>
              NonZero<usize>
              Option<T>
              Option<extern "C" fn() -> M>
              Option<extern "C" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(G, H, I, J, K, L) -> M>
              Option<extern "C" fn(H, I, J, K, L) -> M>
              Option<extern "C" fn(I, J, K, L) -> M>
              Option<extern "C" fn(J, K, L) -> M>
              Option<extern "C" fn(K, L) -> M>
              Option<extern "C" fn(L) -> M>
              Option<fn() -> M>
              Option<fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(E, F, G, H, I, J, K, L) -> M>
              Option<fn(F, G, H, I, J, K, L) -> M>
              Option<fn(G, H, I, J, K, L) -> M>
              Option<fn(H, I, J, K, L) -> M>
              Option<fn(I, J, K, L) -> M>
              Option<fn(J, K, L) -> M>
              Option<fn(K, L) -> M>
              Option<fn(L) -> M>
              Option<unsafe extern "C" fn() -> M>
              Option<unsafe extern "C" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(I, J, K, L) -> M>
              Option<unsafe extern "C" fn(J, K, L) -> M>
              Option<unsafe extern "C" fn(K, L) -> M>
              Option<unsafe extern "C" fn(L) -> M>
              Option<unsafe fn() -> M>
              Option<unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(G, H, I, J, K, L) -> M>
              Option<unsafe fn(H, I, J, K, L) -> M>
              Option<unsafe fn(I, J, K, L) -> M>
              Option<unsafe fn(J, K, L) -> M>
              Option<unsafe fn(K, L) -> M>
              Option<unsafe fn(L) -> M>
              PhantomData<T>
              ReadOnly<T>
              U128<O>
              U16<O>
              U32<O>
              U64<O>
              Unalign<T>
              Usize<O>
              Wrapping<T>
              [T; N]
              [T]
              __m128
              __m128d
              __m128i
              __m256
              __m256d
              __m256i
              __m512
              __m512bh
              __m512d
              __m512i
              bool
              char
              f32
              f64
              i128
              i16
              i32
              i64
              i8
              isize
              std::mem::MaybeUninit<T>
              str
              u128
              u16
              u32
              u64
              u8
              usize
note: required by a bound in `Wrap::<&'a Src, &'a Dst>::try_transmute_ref`
   --> src/util/macro_util.rs
    |
    |     pub fn try_transmute_ref(self) -> Result<&'a Dst, ValidityError<&'a Src, Dst>>
    |            ----------------- required by a bound in this associated function
...
    |         Dst: TryFromBytes + Immutable,
    |                             ^^^^^^^^^ required by this bound in `Wrap::<&Src, &Dst>::try_transmute_ref`
    = note: this error originates in the macro `try_transmute_ref` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `NotZerocopy: TryFromBytes` is not satisfied
 --> tests/ui-stable/try_transmute_ref-dst-not-immutable-tryfrombytes.rs:17:33
  |
 17 |     let dst_not_try_from_bytes: Result<&NotZerocopy, _> = try_transmute_ref!(&AU16(0));
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound
    |
help: the trait `TryFromBytes` is not implemented for `NotZerocopy`
   --> tests/ui-stable/../include.rs
    |
 15 |     pub struct NotZerocopy<T = ()>(pub T);
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: Consider adding `#[derive(TryFromBytes)]` to `NotZerocopy`
    = help: the following other types implement trait `TryFromBytes`:
              ()
              (A, B)
              (A, B, C)
              (A, B, C, D)
              (A, B, C, D, E)
              (A, B, C, D, E, F)
              (A, B, C, D, E, F, G)
              (A, B, C, D, E, F, G, H)
              (A, B, C, D, E, F, G, H, I)
              (A, B, C, D, E, F, G, H, I, J)
              (A, B, C, D, E, F, G, H, I, J, K)
              (A, B, C, D, E, F, G, H, I, J, K, L)
              (A, B, C, D, E, F, G, H, I, J, K, L, M)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z)
              (A,)
              *const T
              *mut T
              AU16
              AtomicBool
              AtomicI16
              AtomicI32
              AtomicI64
              AtomicI8
              AtomicIsize
              AtomicPtr<T>
              AtomicU16
              AtomicU32
              AtomicU64
              AtomicU8
              AtomicUsize
              Cell<T>
              F32<O>
              F64<O>
              I128<O>
              I16<O>
              I32<O>
              I64<O>
              Isize<O>
              ManuallyDrop<T>
              NonZero<i128>
              NonZero<i16>
              NonZero<i32>
              NonZero<i64>
              NonZero<i8>
              NonZero<isize>
              NonZero<u128>
              NonZero<u16>
              NonZero<u32>
              NonZero<u64>
              NonZero<u8>
              NonZero<usize>
              Option<&T>
              Option<&mut T>
              Option<Box<T>>
              Option<NonNull<T>>
              Option<NonZero<i128>>
              Option<NonZero<i16>>
              Option<NonZero<i32>>
              Option<NonZero<i64>>
              Option<NonZero<i8>>
              Option<NonZero<isize>>
              Option<NonZero<u128>>
              Option<NonZero<u16>>
              Option<NonZero<u32>>
              Option<NonZero<u64>>
              Option<NonZero<u8>>
              Option<NonZero<usize>>
              Option<extern "C" fn() -> M>
              Option<extern "C" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(G, H, I, J, K, L) -> M>
              Option<extern "C" fn(H, I, J, K, L) -> M>
              Option<extern "C" fn(I, J, K, L) -> M>
              Option<extern "C" fn(J, K, L) -> M>
              Option<extern "C" fn(K, L) -> M>
              Option<extern "C" fn(L) -> M>
              Option<fn() -> M>
              Option<fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(E, F, G, H, I, J, K, L) -> M>
              Option<fn(F, G, H, I, J, K, L) -> M>
              Option<fn(G, H, I, J, K, L) -> M>
              Option<fn(H, I, J, K, L) -> M>
              Option<fn(I, J, K, L) -> M>
              Option<fn(J, K, L) -> M>
              Option<fn(K, L) -> M>
              Option<fn(L) -> M>
              Option<unsafe extern "C" fn() -> M>
              Option<unsafe extern "C" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(I, J, K, L) -> M>
              Option<unsafe extern "C" fn(J, K, L) -> M>
              Option<unsafe extern "C" fn(K, L) -> M>
              Option<unsafe extern "C" fn(L) -> M>
              Option<unsafe fn() -> M>
              Option<unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(G, H, I, J, K, L) -> M>
              Option<unsafe fn(H, I, J, K, L) -> M>
              Option<unsafe fn(I, J, K, L) -> M>
              Option<unsafe fn(J, K, L) -> M>
              Option<unsafe fn(K, L) -> M>
              Option<unsafe fn(L) -> M>
              PhantomData<T>
              ReadOnly<T>
              U128<O>
              U16<O>
              U32<O>
              U64<O>
              Unalign<T>
              UnsafeCell<T>
              Usize<O>
              Wrapping<T>
              [T; N]
              [T]
              __m128
              __m128d
              __m128i
              __m256
              __m256d
              __m256i
              __m512
              __m512bh
              __m512d
              __m512i
              bool
              char
              f32
              f64
              i128
              i16
              i32
              i64
              i8
              isize
              std::mem::MaybeUninit<T>
              str
              u128
              u16
              u32
              u64
              u8
              usize
note: required by a bound in `ValidityError`
   --> src/error.rs
    |
    | pub struct ValidityError<Src, Dst: ?Sized + TryFromBytes> {
    |                                             ^^^^^^^^^^^^ required by this bound in `ValidityError`

error[E0277]: the trait bound `NotZerocopy: TryFromBytes` is not satisfied
 --> tests/ui-stable/try_transmute_ref-dst-not-immutable-tryfrombytes.rs:17:59
  |
 17 |     let dst_not_try_from_bytes: Result<&NotZerocopy, _> = try_transmute_ref!(&AU16(0));
    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound
    |
help: the trait `TryFromBytes` is not implemented for `NotZerocopy`
   --> tests/ui-stable/../include.rs
    |
 15 |     pub struct NotZerocopy<T = ()>(pub T);
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: Consider adding `#[derive(TryFromBytes)]` to `NotZerocopy`
    = help: the following other types implement trait `TryFromBytes`:
              ()
              (A, B)
              (A, B, C)
              (A, B, C, D)
              (A, B, C, D, E)
              (A, B, C, D, E, F)
              (A, B, C, D, E, F, G)
              (A, B, C, D, E, F, G, H)
              (A, B, C, D, E, F, G, H, I)
              (A, B, C, D, E, F, G, H, I, J)
              (A, B, C, D, E, F, G, H, I, J, K)
              (A, B, C, D, E, F, G, H, I, J, K, L)
              (A, B, C, D, E, F, G, H, I, J, K, L, M)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y)
              (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z)
              (A,)
              *const T
              *mut T
              AU16
              AtomicBool
              AtomicI16
              AtomicI32
              AtomicI64
              AtomicI8
              AtomicIsize
              AtomicPtr<T>
              AtomicU16
              AtomicU32
              AtomicU64
              AtomicU8
              AtomicUsize
              Cell<T>
              F32<O>
              F64<O>
              I128<O>
              I16<O>
              I32<O>
              I64<O>
              Isize<O>
              ManuallyDrop<T>
              NonZero<i128>
              NonZero<i16>
              NonZero<i32>
              NonZero<i64>
              NonZero<i8>
              NonZero<isize>
              NonZero<u128>
              NonZero<u16>
              NonZero<u32>
              NonZero<u64>
              NonZero<u8>
              NonZero<usize>
              Option<&T>
              Option<&mut T>
              Option<Box<T>>
              Option<NonNull<T>>
              Option<NonZero<i128>>
              Option<NonZero<i16>>
              Option<NonZero<i32>>
              Option<NonZero<i64>>
              Option<NonZero<i8>>
              Option<NonZero<isize>>
              Option<NonZero<u128>>
              Option<NonZero<u16>>
              Option<NonZero<u32>>
              Option<NonZero<u64>>
              Option<NonZero<u8>>
              Option<NonZero<usize>>
              Option<extern "C" fn() -> M>
              Option<extern "C" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(E, F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(F, G, H, I, J, K, L) -> M>
              Option<extern "C" fn(G, H, I, J, K, L) -> M>
              Option<extern "C" fn(H, I, J, K, L) -> M>
              Option<extern "C" fn(I, J, K, L) -> M>
              Option<extern "C" fn(J, K, L) -> M>
              Option<extern "C" fn(K, L) -> M>
              Option<extern "C" fn(L) -> M>
              Option<fn() -> M>
              Option<fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<fn(E, F, G, H, I, J, K, L) -> M>
              Option<fn(F, G, H, I, J, K, L) -> M>
              Option<fn(G, H, I, J, K, L) -> M>
              Option<fn(H, I, J, K, L) -> M>
              Option<fn(I, J, K, L) -> M>
              Option<fn(J, K, L) -> M>
              Option<fn(K, L) -> M>
              Option<fn(L) -> M>
              Option<unsafe extern "C" fn() -> M>
              Option<unsafe extern "C" fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(E, F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(F, G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(G, H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(H, I, J, K, L) -> M>
              Option<unsafe extern "C" fn(I, J, K, L) -> M>
              Option<unsafe extern "C" fn(J, K, L) -> M>
              Option<unsafe extern "C" fn(K, L) -> M>
              Option<unsafe extern "C" fn(L) -> M>
              Option<unsafe fn() -> M>
              Option<unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(B, C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(C, D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(D, E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(E, F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(F, G, H, I, J, K, L) -> M>
              Option<unsafe fn(G, H, I, J, K, L) -> M>
              Option<unsafe fn(H, I, J, K, L) -> M>
              Option<unsafe fn(I, J, K, L) -> M>
              Option<unsafe fn(J, K, L) -> M>
              Option<unsafe fn(K, L) -> M>
              Option<unsafe fn(L) -> M>
              PhantomData<T>
              ReadOnly<T>
              U128<O>
              U16<O>
              U32<O>
              U64<O>
              Unalign<T>
              UnsafeCell<T>
              Usize<O>
              Wrapping<T>
              [T; N]
              [T]
              __m128
              __m128d
              __m128i
              __m256
              __m256d
              __m256i
              __m512
              __m512bh
              __m512d
              __m512i
              bool
              char
              f32
              f64
              i128
              i16
              i32
              i64
              i8
              isize
              std::mem::MaybeUninit<T>
              str
              u128
              u16
              u32
              u64
              u8
              usize
note: required by a bound in `ValidityError`
   --> src/error.rs
    |
    | pub struct ValidityError<Src, Dst: ?Sized + TryFromBytes> {
    |                                             ^^^^^^^^^^^^ required by this bound in `ValidityError`
    = note: this error originates in the macro `try_transmute_ref` (in Nightly builds, run with -Z macro-backtrace for more info)
