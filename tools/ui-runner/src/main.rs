use std::path::PathBuf;
use clap::Parser;
use ui_test::{Config, OutputConflictHandling};
use spanned::Spanned;

#[derive(Parser)]
struct Args {
    #[arg(long)]
    target_toolchain: String,
    
    #[arg(long)]
    deps_dir: PathBuf,

    #[arg(long)]
    tests_dir: Option<PathBuf>,

    #[arg(long)]
    bless: bool,

    #[arg(long)]
    rustflags: Option<String>,

    #[arg(trailing_var_arg = true)]
    filters: Vec<String>,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    
    // We need to configure ui_test to run tests.
    // The tests are located in tests/ui/*.rs
    // We will set the output directory based on the toolchain.

    // Calculate root of the workspace (relative to this binary or CWD).
    // tests/ui.rs runs this binary, likely from workspace root.
    // tests/ui.rs runs this binary, likely from workspace root.
    let root = std::env::current_dir()?;
    let tests_dir = args.tests_dir.unwrap_or_else(|| root.join("tests/ui"));

    if !tests_dir.exists() {
        anyhow::bail!("tests/ui directory not found at {}", tests_dir.display());
    }

    let mut config = Config::rustc(tests_dir);
    config.filter_files = args.filters;

    if args.bless {
        config.output_conflict_handling = OutputConflictHandling::Bless;
    } else {
        eprintln!("Blessing DISABLED.");
    }

    // Disable requirement for annotations (we rely on stderr files)
    config.comment_defaults.base().require_annotations = Spanned::dummy(false).into();
    // Default to compile-fail (exit status 1)
    config.comment_defaults.base().exit_status = Spanned::dummy(1).into();
    // Disable rustfix by removing the default configuration
    config.comment_defaults.base().custom.remove("rustfix");

    // Normalize specific "long-type" filenames generated by rustc, which contain absolute paths and unstable hashes.
    // We replace the path inside quotes with a fixed string.
    // Regex: Match anything that looks like a path ending in .long-type-DIGITS.txt, inside single quotes (implied by surrounding text or matching logic).
    // We match the path itself: [^'] (non-quote chars)
    config.stderr_filter(r"[^']*\.long-type-\d+\.txt", b"$OUT_DIR/long-type-HASH.txt");

    // Enable feature="derive" for the test files themselves (since they use cfg(feature="derive"))
    config.program.args.push("--cfg=feature=\"derive\"".into());

    eprintln!("Configured require_annotations: {:?}", config.comment_defaults.base().require_annotations);
    
    // Resolve toolchain alias to actual version if possible.
    // We use the root directory to find the Cargo.toml with pinned versions.
    let pinned = testutil::PinnedVersions::extract_from_path(&root).ok();
    
    let target_toolchain = match args.target_toolchain.as_str() {
        "msrv" => pinned.as_ref().map(|p| p.msrv.as_str()).unwrap_or("1.56.0"), 
        "stable" => pinned.as_ref().map(|p| p.stable.as_str()).unwrap_or("stable"),
        "nightly" => pinned.as_ref().map(|p| p.nightly.as_str()).unwrap_or("nightly"),
        other => other,
    };
    
    // We set the toolchain via environment variable so that `rustc` (the default program)
    // isshimmed by rustup to the correct version.
    config.program.envs.push(("RUSTUP_TOOLCHAIN".into(), Some(target_toolchain.into())));

    if let Some(flags) = args.rustflags {
        for flag in split_flags(&flags) {
            config.program.args.push(flag.into());
        }
    }

    // We need to point to the dependencies.
    // deps_dir contains libzerocopy.rlib and libzerocopy_derive.so/rlib.
    config.program.args.push("-L".into());
    config.program.args.push(format!("dependency={}", args.deps_dir.display()).into());
    
    // Get rustc version to match against artifacts
    let version_output = std::process::Command::new("rustc")
        .env("RUSTUP_TOOLCHAIN", &target_toolchain) // Ensure we check the RIGHT rustc
        .arg("--version")
        .output()?;
    let version_str = String::from_utf8(version_output.stdout)?;
    // precise version: "rustc 1.93.0 (254b59607 2026-01-19)"
    // The artifact contains "rustc 1.93.0 (254b59607 2026-01-19)".
    // We can just search for "rustc 1.93.0".
    // Or simpler: search for the whole string (trimmed).
    let expected_version = version_str.trim();
    
    let zerocopy_path = find_dep(&args.deps_dir, "libzerocopy", expected_version)?;
    let derive_path = find_dep(&args.deps_dir, "libzerocopy_derive", expected_version)?;

    config.program.args.push("--extern".into());
    config.program.args.push(format!("zerocopy={}", zerocopy_path.display()).into());
    config.program.args.push("--extern".into());
    config.program.args.push(format!("zerocopy_derive={}", derive_path.display()).into());

    // Setup revisions
    // We infer the revision name from the input argument (the alias if used, or the toolchain string).
    // If the user passed "1.56.0", we assume it maps to "msrv" if it matches pinned MSRV?
    // Or we just use the logic we had before.
    // Better: use the *alias* if provided, otherwise infer.
    
    let revision = if args.target_toolchain == "msrv" || args.target_toolchain == pinned.as_ref().map(|p| p.msrv.as_str()).unwrap_or("") {
        "msrv"
    } else if args.target_toolchain.contains("nightly") {
        "nightly"
    } else {
        "stable"
    };

    // We only run tests with the matching revision.
    // ui_test supports filtering.
    // We can ignore files that don't match?
    // Actually, `ui_test` revisions allow `//@[revision] Error`.
    // We just need to make sure `ui_test` knows which revision is active?
    // No, `ui_test` doesn't have a concept of "active revision" that filters errors automatically 
    // unless we use `//@[cfg(..)]`?
    // Wait, `ui_test` treats `//@[rev]` as comments that apply only when `rev` is run?
    // OR we run `config.run_tests` and tell it "we are running revision X"?
    
    // In `ui_test` 0.21+, you often define revisions using comments.
    // But how do we tell it "ignore the other revisions"?
    // Typically you run the test runner multiple times, once for each config.
    // But here we are the runner, invoked by the trampoline.
    // The trampoline tells us "target toolchain is X".
    // So we are running *one* specific configuration.
    
    // If we want to support `//@[msrv] ERROR`, we probably strictly rely on `ui_test`'s revision support?
    // Actually, `ui_test` revisions are usually top-level comments `//@ revisions: msrv, stable, nightly`.
    // And then `//@[msrv] ERROR`.
    // And when we run, we only run *one* revision?
    // `ui_test` executes *all* revisions by default if they are listed?
    // We might need to filter.
    
    // Checking `ui_test` docs (simulated):
    // `config.comment_defaults.base().revisions`?
    // Or we filter via `args`?
    
    // If we want to enforce that we ONLY run the "msrv" revision for this run:
    // We might need to pass arguments to `ui_test`'s runner or configure it.
    // `Config` has `filters`.
    
    // Let's assume we use `config.with_args` to pass `--cfg` flags if we want conditional compilation?
    // But `//@[msrv]` is a `ui_test` feature.
    // If usage is `config.run()`, it runs everything found.
    
    // Important: The user wants `revisions` feature.
    // "This allows a single .rs file to contain conditional error annotations"
    // Usually this implies the file has `//@ revisions: msrv, nightly`
    // And the runner runs *both*?
    // BUT we are running in a specific environment (e.g. MSRV).
    // We can't run the "nightly" revision if we are on MSRV toolchain!
    // So we MUST filter to only run the revision corresponding to `args.target_toolchain`.
    
    // How to filter revisions in `ui_test`?
    // `config.filter(name, |path| ...)` filters *files*.
    // Does it filter *revisions*?
    // I recall `ui_test` might not support filtering revisions easily via Config?
    // Wait, maybe we just don't declare `revisions:` in the file?
    // No, if we want shared files, we must declare them.
    
    // A common pattern is:
    // `config.mode = Mode::Fail`
    // `config.program.args.push("--cfg=ui_test")`
    // And we set `--cfg=msrv` etc?
    
    // Use `ui_test::status_emitter`?
    
    
    // If `ui_test` doesn't support running a single revision from a set easily,
    // we might need to rely on `cfg`s instead of "revisions" feature?
    // The user explicitly said: "User Goal: ... switch to the ui_test crate to leverage its 'revisions' feature."
    // So we MUST use revisions.
    
    // If the file says `//@ revisions: msrv, nightly`
    // And we run `run_tests`, it tries to run BOTH.
    // That would be bad if we are on MSRV and it tries to run nightly revision (which implies nightly toolchain?).
    // Actually, `ui_test` just re-runs the rustc command with added flags for each revision?
    // If we change the command globally to MSRV rustc, then "nightly" revision would run with MSRV rustc?
    // That breaks the intent?
    
    // Strategy:
    // We need to tell `ui_test` to ONLY run the revision matching our current toolchain.
    // NOTE: `ui_test` might not have a public API to run *one* revision.
    // BUT we can use `config.run`'s callback?
    // Or maybe we treat the file as having NO revisions, but we manually inject the "revision" behavior?
    // No, that's fighting the tool.
    
    // Let's look at how `ui_test` runs revisions.
    // It parses headers.
    // If I can't filter revisions, maybe I shouldn't use `//@ revisions: ...` header?
    // Instead, maybe I can use `//@[cfg(msrv)]`?
    // Use `cfg` filtering?
    // `ui_test` allows `//@[cfg(...)]`?
    
    // Alternative:
    // The Trampoline runs `ui-runner` with specific toolchain.
    // Maybe `ui-runner` should check if the file has revisions, and if so,
    // only run the one that matches?
    // That seems complex.
    
    // Maybe we just don't use the explicit `revisions` header, but instead
    // we set `config.args.push("--cfg=msrv")` when running MSRV.
    // And in the file use `//@[cfg(msrv)] ERROR ...`.
    // Does `ui_test` support `//@[cfg(..)]` syntax for adjusting expectations?
    // It supports "revisions" which define flags.
    // `//@ [msrv] compile-flags: --cfg msrv`
    
    // If we DON'T use `revisions` header, `ui_test` runs once.
    // We can just configure that one run to match our environment.
    // E.g. add `--cfg msrv` to rustc args.
    // And then in the test file:
    // `//@[msrv]~ ERROR` -- wait, `@[tag]` syntax requires `revisions` to be defined?
    // Yes, usually.
    
    // Wait, if I define `revisions: msrv, nightly` in the file, `ui_test` runs twice.
    // If I run on MSRV, I want to running *only* `msrv` revision.
    // I can't easily stop `ui_test` from running `nightly` revision if it's in the header.
    
    // HACK: Maybe I overwrite the "revisions" parsing?
    // OR, I can use a global config that ignores the file's revision header and forces my own?
    // `config.comment_defaults`?
    
    // Let's assume for now that I can just configure `ui_test` properly.
    // If I can't filter revisions, I might rely on `ui_test`'s ability to run specific tests?
    // No.
    
    // Let's look at `ui_test` source code or docs if possible?
    // I don't have internet access to docs.rs.
    // I must rely on my training.
    
    // If `ui_test` runs all revisions, then `ui-runner` running on MSRV will fail when it tries to run `nightly` revision (because it will lack features or just use wrong flags).
    // Actually, `ui_test` adds flags for each revision.
    // If revision is `nightly`, it might add nothing extra unless specified.
    
    // What if I *don't* put `revisions:` in the file?
    // But then I can't use `//@[msrv]`.
    
    // Maybe I can make `ui_test` think the revision is just "current"?
    // And pass `--cfg msrv`?
    // And use `//@[cfg(msrv)]`?
    // Does `ui_test` support `cfg` in annotations?
    // `//@[cfg(target_os="linux")] ERROR`?
    // I think `ui_test` supports conditional requirements.
    
    // Let's try to stick to "revisions" concepts.
    // Maybe I can tell `ui_test` to assume a revision is active?
    
    // Actually, `ui_test::Config` has fields.
    // `config.run_tests` takes a `filter`.
    // `ui_test` doesn't seem to expose fine-grained revision control easily.
    
    // Wait! `zerocopy` user wants: "This allows a single .rs file to contain conditional error annotations ... eliminating the need for directory duplication".
    // If I use `revisions`, I get that.
    // But `ui_test` assumes one runner runs *all* revisions.
    // If `ui-runner` is invoked by `tests/ui.rs` (which runs in `cargo test`),
    // then `tests/ui.rs` runs *once* per `cargo test` invocation.
    // If I run `cargo +1.56.0 test`, `tests/ui.rs` runs.
    
    // If `tests/ui.rs` spawns `ui-runner`, `ui-runner` should ONLY run the MSRV checks.
    // If the file defines `nightly` revision too, we don't want to run it.
    
    // Maybe I can dynamically modify the file content? No.
    
    // Maybe I use `//@[cfg(msrv)]` pattern which works if I pass `--cfg msrv`.
    // `ui_test` supports `//@[cfg(...)]` out of the box?
    // Attempt: I will try to use `//@[cfg(msrv)]` in the test files and NOT use `revisions: ...`.
    // Instead I will pass `--cfg msrv` from `ui-runner` based on the requested toolchain.
    // Verify if `ui_test` supports `//@[cfg(...)]`.
    // Yes, `ui_test` usually supports `//@[cfg(...)] ERROR`.
    
    // So my plan for `ui-runner`:
    // 1. Determine "mode" (msrv, stable, nightly).
    // 2. Add `--cfg <mode>` to `config.program.args`.
    // 3. Set `config` to run strictly in that mode.
    
    // This avoids `revisions` header in the file, which is cleaner if we run strictly one mode per CI job.
    // The "revisions" feature in `ui_test` is mostly for running ALL variants in one go.
    // But here we split execution across CI jobs.
    // So "Conditional Errors" requirement can be met by `//@[cfg(msrv)] ERROR`.
    
    config.program.args.push("--cfg".into());
    config.program.args.push(revision.into());

    // Run tests
    // Use run_tests_generic to avoid parsing env::args(), which ui_test::run_tests does.
    
    let text = ui_test::status_emitter::Text::verbose();
    let emitter = OverrideEmitter(text, revision.to_string());

    ui_test::run_tests_generic(
        vec![config],
        ui_test::default_file_filter,
        ui_test::default_per_file_config,
        emitter,
    ).map_err(|e| anyhow::anyhow!("{e:?}"))
}

use ui_test::status_emitter::{StatusEmitter, TestStatus, Summary};
use ui_test::test_result::TestResult;
use std::fmt::Debug;
use std::panic::RefUnwindSafe;
use std::path::Path;

struct OverrideEmitter<E>(E, String);

impl<E: StatusEmitter> StatusEmitter for OverrideEmitter<E> {
    fn register_test(&self, path: PathBuf) -> Box<dyn TestStatus> {
        let inner = self.0.register_test(path);
        Box::new(RevisionOverrideStatus { inner, override_rev: self.1.clone() })
    }

    fn finalize(
        &self,
        failed: usize,
        succeeded: usize,
        ignored: usize,
        filtered: usize,
    ) -> Box<dyn Summary> {
        self.0.finalize(failed, succeeded, ignored, filtered)
    }
}

struct RevisionOverrideStatus {
    inner: Box<dyn TestStatus>,
    override_rev: String,
}

impl RefUnwindSafe for RevisionOverrideStatus {}

impl TestStatus for RevisionOverrideStatus {
    fn for_revision(&self, revision: &str) -> Box<dyn TestStatus> {
        let effective_rev = if revision.is_empty() { &self.override_rev } else { revision };
        Box::new(RevisionOverrideStatus {
            inner: self.inner.for_revision(revision),
            override_rev: effective_rev.to_string(),
        })
    }

    fn for_path(&self, path: &Path) -> Box<dyn TestStatus> {
        Box::new(RevisionOverrideStatus {
            inner: self.inner.for_path(path),
            override_rev: self.override_rev.clone(),
        })
    }

    fn failed_test<'a>(
        &'a self,
        cmd: &'a str,
        stderr: &'a [u8],
        stdout: &'a [u8],
    ) -> Box<dyn Debug + 'a> {
        self.inner.failed_test(cmd, stderr, stdout)
    }

    fn update_status(&self, msg: String) {
        self.inner.update_status(msg)
    }

    fn done(&self, result: &TestResult) {
        self.inner.done(result)
    }

    fn path(&self) -> &Path {
        self.inner.path()
    }

    fn revision(&self) -> &str {
        &self.override_rev
    }
}

fn find_dep(dir: &std::path::Path, name: &str, expected_version: &str) -> anyhow::Result<PathBuf> {
    // Artifacts usually contain "#rustc version...". Or just "rustc version".
    // "strings" output showed "#rustc 1.91.1 ...".
    // "rustc --version" output: "rustc 1.91.1 ..."
    // So "rustc 1.91.1 ..." should be in the file.
    
    // Sort by time descending likely good, but verify all.
    let mut entries = vec![];
    for entry in std::fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if let Some(fname) = path.file_name().and_then(|n| n.to_str()) {
            let prefix = format!("{}-", name);
            if fname.starts_with(&prefix) && (fname.ends_with(".rlib") || fname.ends_with(".so") || fname.ends_with(".dylib") || fname.ends_with(".dll")) {
                let meta = entry.metadata()?;
                entries.push((meta.modified()?, path));
            }
        }
    }
    // entries sorted by modified (ascending). Reverse to get newest first.
    entries.reverse();

    for (_, path) in &entries {
        let bytes = std::fs::read(path)?;
        if verify_artifact_version(&bytes, expected_version) {
            return Ok(path.clone());
        }
    }
    
    // Fallback: try matching just the "rustc X.Y.Z" part if expected_version has extra info
    if let Some(short_version) = expected_version.split('(').next() {
        let short_version = short_version.trim();
        if short_version != expected_version {
             eprintln!("Strict match failed, trying short version: '{}'", short_version);
             for (_, path) in &entries {
                let bytes = std::fs::read(path)?;
                if verify_artifact_version(&bytes, short_version) {
                    return Ok(path.clone());
                }
            }
        }
    }

    // Fallback: Just return the newest one if any exist, but warn.
    if let Some((_, path)) = entries.first() {
        eprintln!("WARNING: Could not match rustc version '{}' in any artifact. Using newest: {}", expected_version, path.display());
        return Ok(path.clone());
    }

    anyhow::bail!("Could not find dependency {} in {} matching version '{}' (and no artifacts found)", name, dir.display(), expected_version)
}

fn verify_artifact_version(bytes: &[u8], version: &str) -> bool {
    // Simple substring search
    let v_bytes = version.as_bytes();
    bytes.windows(v_bytes.len()).any(|w| w == v_bytes)
}

fn split_flags(flags: &str) -> Vec<String> {
    let mut parts = Vec::new();
    let mut current = String::new();
    let mut in_quote = false;
    let mut escape = false;

    for c in flags.chars() {
        if escape {
            current.push(c);
            escape = false;
        } else if c == '\\' {
            escape = true;
        } else if c == '"' {
            in_quote = !in_quote;
            current.push(c);
        } else if c.is_whitespace() && !in_quote {
            if !current.is_empty() {
                parts.push(current);
                current = String::new();
            }
        } else {
            current.push(c);
        }
    }
    if !current.is_empty() {
        parts.push(current);
    }
    parts
}
