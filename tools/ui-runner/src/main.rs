use std::path::PathBuf;

use clap::Parser;
use spanned::Spanned;
use ui_test::{Config, OutputConflictHandling};

#[derive(Parser)]
struct Args {
    #[arg(long)]
    target_toolchain: String,

    #[arg(long)]
    deps_dir: PathBuf,

    #[arg(long)]
    host_deps_dir: Option<PathBuf>,

    #[arg(long)]
    tests_dir: Option<PathBuf>,

    #[arg(long)]
    bless: bool,

    #[arg(long)]
    rustflags: Option<String>,

    #[arg(trailing_var_arg = true)]
    filters: Vec<String>,

    /// Skip tests with names matching the given pattern.
    #[arg(long)]
    skip: Vec<String>,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    let root = std::env::current_dir()?;
    let tests_dir = args.tests_dir.unwrap_or_else(|| root.join("tests/ui"));

    if !tests_dir.exists() {
        anyhow::bail!("tests/ui directory not found at {}", tests_dir.display());
    }

    let mut config = Config::rustc(tests_dir.clone());

    config.stderr_filter(&tests_dir.display().to_string(), "$$DIR");
    if let Ok(canonical) = std::fs::canonicalize(&tests_dir) {
        let canonical_str = canonical.display().to_string();
        config.stderr_filter(&canonical_str, "$$DIR");
    }

    if args.bless {
        config.output_conflict_handling = OutputConflictHandling::Bless;
    }

    // Disable requirement for annotations (we rely on stderr files)
    config.comment_defaults.base().require_annotations = Spanned::dummy(false).into();
    // Default to compile-fail (exit status 1)
    config.comment_defaults.base().exit_status = Spanned::dummy(1).into();
    // Disable rustfix by removing the default configuration
    config.comment_defaults.base().custom.remove("rustfix");

    // Normalize specific "long-type" filenames generated by rustc, which
    // contain absolute paths and unstable hashes.
    config.stderr_filter(r"[^']*\.long-type-\d+\.txt", b"$OUT_DIR/long-type-HASH.txt");

    // Enable feature="derive" for the test files themselves (since they use cfg(feature="derive"))
    config.program.args.push("--cfg=feature=\"derive\"".into());

    // // Force rustc to print full type names instead of writing them to a file for long types.
    // config.program.args.push("--verbose".into());

    let pinned = testutil::PinnedVersions::extract_from_path(&root).ok();

    let target_toolchain = match args.target_toolchain.as_str() {
        "msrv" => pinned.as_ref().map(|p| p.msrv.as_str()).unwrap(),
        "stable" => pinned.as_ref().map(|p| p.stable.as_str()).unwrap(),
        "nightly" => pinned.as_ref().map(|p| p.nightly.as_str()).unwrap(),
        other => other,
    };

    // We set the toolchain via environment variable so that `rustc` (the default program)
    // is shimmed by rustup to the correct version.
    config.program.envs.push(("RUSTUP_TOOLCHAIN".into(), Some(target_toolchain.into())));

    // Force a consistent terminal width and type to avoid line wrapping diffs.
    config.program.envs.push(("TERM".into(), Some("dumb".into())));
    config.program.envs.push(("COLUMNS".into(), Some("100".into())));

    if let Some(flags) = args.rustflags {
        for flag in split_flags(&flags) {
            config.program.args.push(flag.into());
        }
    }

    // We need to point to the dependencies.
    // deps_dir contains libzerocopy.rlib and libzerocopy_derive.so/rlib.
    config.program.args.push("-L".into());
    config.program.args.push(format!("dependency={}", args.deps_dir.display()).into());

    // Get rustc version to match against artifacts
    let version_output = std::process::Command::new("rustc")
        .env("RUSTUP_TOOLCHAIN", &target_toolchain) // Ensure we check the RIGHT rustc
        .arg("--version")
        .output()?;
    let version_str = String::from_utf8(version_output.stdout)?;
    let expected_version = version_str.trim();

    let zerocopy_path = find_dep(&args.deps_dir, "libzerocopy", expected_version)?;
    let derive_path = if let Ok(path) = std::env::var("ZEROCOPY_DERIVE_LIB_PATH") {
        PathBuf::from(path)
    } else {
        // zerocopy-derive is a proc-macro, so it might be in host deps
        let search_dir = args.host_deps_dir.as_ref().unwrap_or(&args.deps_dir);
        find_dep(search_dir, "libzerocopy_derive", expected_version)?
    };

    config.program.args.push("--extern".into());
    config.program.args.push(format!("zerocopy={}", zerocopy_path.display()).into());
    config.program.args.push("--extern".into());
    config.program.args.push(format!("zerocopy_renamed={}", zerocopy_path.display()).into()); // Alias for tests
    config.program.args.push("--extern".into());
    config.program.args.push(format!("zerocopy_derive={}", derive_path.display()).into());

    // Link static_assertions if available (used by zerocopy-derive tests)
    if let Ok(sa_path) = find_dep(&args.deps_dir, "libstatic_assertions", "1.1") {
        config.program.args.push("--extern".into());
        config.program.args.push(format!("static_assertions={}", sa_path.display()).into());
    }

    let revision = if args.target_toolchain == "msrv"
        || args.target_toolchain == pinned.as_ref().map(|p| p.msrv.as_str()).unwrap_or("")
    {
        "msrv"
    } else if args.target_toolchain.contains("nightly") {
        "nightly"
    } else {
        "stable"
    };

    // We only run tests with the matching revision.
    //
    // `ui_test` usually runs all defined revisions (e.g. `//@ revisions: msrv, stable`).
    // Since we are invoking this runner for a *specific* toolchain, we must ensure
    // we only run the corresponding revision.
    //
    // We achieve this by:
    // 1. Passing `--cfg <revision>` to rustc (via `config.program.args`), which allows
    //    `//@[cfg(<revision>)]` annotations to work.
    // 2. Using a custom `StatusEmitter` (`OverrideEmitter`) which wraps the default one.
    //    It enforces that `ui_test` believes it is running the specified `revision`,
    //    regardless of what revisions are defined in the file header.
    //    This effectively filters the errors/output expectation to the target revision.

    config.program.args.push("--cfg".into());
    config.program.args.push(revision.into());

    let text = ui_test::status_emitter::Text::verbose();
    let emitter = OverrideEmitter(text, revision.to_string());

    // Split filters into includes (default) and excludes (starting with '!')
    let (includes, mut excludes): (Vec<_>, Vec<_>) =
        args.filters.into_iter().partition(|s| !s.starts_with('!'));

    // Add explicitly skipped tests to excludes
    for skip in args.skip {
        excludes.push(skip);
    }

    let excludes: Vec<String> =
        excludes.into_iter().map(|s| s.trim_start_matches('!').to_string()).collect();

    config.filter_files = includes;

    let file_filter = move |path: &Path, config: &Config| {
        if excludes.iter().any(|ex| path.to_string_lossy().contains(ex)) {
            return Some(false);
        }
        ui_test::default_file_filter(path, config)
    };

    ui_test::run_tests_generic(vec![config], file_filter, ui_test::default_per_file_config, emitter)
        .map_err(|e| anyhow::anyhow!("{e:?}"))
}

use std::{fmt::Debug, panic::RefUnwindSafe, path::Path};

use ui_test::{
    status_emitter::{StatusEmitter, Summary, TestStatus},
    test_result::TestResult,
};

struct OverrideEmitter<E>(E, String);

impl<E: StatusEmitter> StatusEmitter for OverrideEmitter<E> {
    fn register_test(&self, path: PathBuf) -> Box<dyn TestStatus> {
        let inner = self.0.register_test(path);
        Box::new(RevisionOverrideStatus { inner, override_rev: self.1.clone() })
    }

    fn finalize(
        &self,
        failed: usize,
        succeeded: usize,
        ignored: usize,
        filtered: usize,
    ) -> Box<dyn Summary> {
        self.0.finalize(failed, succeeded, ignored, filtered)
    }
}

struct RevisionOverrideStatus {
    inner: Box<dyn TestStatus>,
    override_rev: String,
}

impl RefUnwindSafe for RevisionOverrideStatus {}

impl TestStatus for RevisionOverrideStatus {
    fn for_revision(&self, revision: &str) -> Box<dyn TestStatus> {
        let effective_rev = if revision.is_empty() { &self.override_rev } else { revision };
        Box::new(RevisionOverrideStatus {
            inner: self.inner.for_revision(revision),
            override_rev: effective_rev.to_string(),
        })
    }

    fn for_path(&self, path: &Path) -> Box<dyn TestStatus> {
        Box::new(RevisionOverrideStatus {
            inner: self.inner.for_path(path),
            override_rev: self.override_rev.clone(),
        })
    }

    fn failed_test<'a>(
        &'a self,
        cmd: &'a str,
        stderr: &'a [u8],
        stdout: &'a [u8],
    ) -> Box<dyn Debug + 'a> {
        self.inner.failed_test(cmd, stderr, stdout)
    }

    fn update_status(&self, msg: String) {
        self.inner.update_status(msg)
    }

    fn done(&self, result: &TestResult) {
        self.inner.done(result)
    }

    fn path(&self) -> &Path {
        self.inner.path()
    }

    fn revision(&self) -> &str {
        &self.override_rev
    }
}

fn find_dep(dir: &std::path::Path, name: &str, expected_version: &str) -> anyhow::Result<PathBuf> {
    // Artifacts contain the `rustc` version string (e.g., "rustc 1.91.1 ...").
    // We search for this string to ensure we link against the correct set of dependencies.

    // Sort by modification time (descending) to prefer newer artifacts.
    let mut entries = vec![];
    for entry in std::fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if let Some(fname) = path.file_name().and_then(|n| n.to_str()) {
            let prefix = format!("{}-", name);
            if fname.starts_with(&prefix)
                && (fname.ends_with(".rlib")
                    || fname.ends_with(".so")
                    || fname.ends_with(".dylib")
                    || fname.ends_with(".dll"))
            {
                let meta = entry.metadata()?;
                entries.push((meta.modified()?, path));
            }
        }
    }
    // entries sorted by modified (ascending). Reverse to get newest first.
    entries.reverse();

    for (_, path) in &entries {
        let bytes = std::fs::read(path)?;
        if verify_artifact_version(&bytes, expected_version) {
            return Ok(path.clone());
        }
    }

    // Fallback: try matching just the "rustc X.Y.Z" part if expected_version has extra info
    if let Some(short_version) = expected_version.split('(').next() {
        let short_version = short_version.trim();
        if short_version != expected_version {
            eprintln!("Strict match failed, trying short version: '{}'", short_version);
            for (_, path) in &entries {
                let bytes = std::fs::read(path)?;
                if verify_artifact_version(&bytes, short_version) {
                    return Ok(path.clone());
                }
            }
        }
    }

    // Fallback: Just return the newest one if any exist, but warn.
    if let Some((_, path)) = entries.first() {
        eprintln!(
            "WARNING: Could not match rustc version '{}' in any artifact. Using newest: {}",
            expected_version,
            path.display()
        );
        return Ok(path.clone());
    }

    anyhow::bail!(
        "Could not find dependency {} in {} matching version '{}' (and no artifacts found)",
        name,
        dir.display(),
        expected_version
    )
}

fn verify_artifact_version(bytes: &[u8], version: &str) -> bool {
    // Simple substring search
    let v_bytes = version.as_bytes();
    bytes.windows(v_bytes.len()).any(|w| w == v_bytes)
}

fn split_flags(flags: &str) -> Vec<String> {
    let mut parts = Vec::new();
    let mut current = String::new();
    let mut in_quote = false;
    let mut escape = false;

    for c in flags.chars() {
        if escape {
            current.push(c);
            escape = false;
        } else if c == '\\' {
            escape = true;
        } else if c == '"' {
            in_quote = !in_quote;
            current.push(c);
        } else if c.is_whitespace() && !in_quote {
            if !current.is_empty() {
                parts.push(current);
                current = String::new();
            }
        } else {
            current.push(c);
        }
    }
    if !current.is_empty() {
        parts.push(current);
    }
    parts
}
